# 缓存接口修复说明

## 问题描述

```
ERROR | [情绪工具] 获取市场情绪数据失败: SentimentCacheManager.get() missing 1 required positional argument: 'data_type'
```

数据源和缓存管理器之间的接口不匹配。

## 问题原因

### 数据源的调用方式（错误）

```python
# 数据源生成自己的缓存键
cache_key = self._generate_cache_key(ticker, date, **kwargs)

# 调用缓存管理器时只传一个参数
cached_data = self.cache.get(cache_key)  # ❌ 缺少参数
```

### 缓存管理器的期望接口

```python
def get(self, ticker: str, data_type: str, date: Optional[str] = None, **kwargs):
    # 需要ticker, data_type, date等多个参数
    ...
```

## 解决方案

修改数据源的缓存调用方式，使用缓存管理器的正确接口。

### 修改前

```python
def get_data(self, ticker: str, date: str, **kwargs) -> Dict[str, Any]:
    # 生成缓存键
    cache_key = self._generate_cache_key(ticker, date, **kwargs)
    
    # 尝试从缓存获取
    if self.cache:
        cached_data = self.cache.get(cache_key)  # ❌ 错误的调用方式
        if cached_data is not None:
            return cached_data
    
    # 获取新数据
    data = self._fetch_data(ticker, date, **kwargs)
    
    # 存入缓存
    if self.cache and data:
        ttl = self._get_cache_ttl()
        self.cache.set(cache_key, data, ttl=ttl)  # ❌ 错误的调用方式
```

### 修改后

```python
def get_data(self, ticker: str, date: str, **kwargs) -> Dict[str, Any]:
    # 使用数据源名称作为data_type
    data_type = self.source_name.lower().replace('datasource', '')
    
    # 尝试从缓存获取
    if self.cache:
        cached_data = self.cache.get(ticker, data_type, date, **kwargs)  # ✅ 正确
        if cached_data is not None:
            return cached_data
    
    # 获取新数据
    data = self._fetch_data(ticker, date, **kwargs)
    
    # 存入缓存
    if self.cache and data:
        ttl = self._get_cache_ttl()
        self.cache.set(ticker, data_type, data, date, ttl=ttl, **kwargs)  # ✅ 正确
```

## 技术细节

### data_type 的生成

```python
# 数据源类名 -> data_type
CoreSentimentDataSource -> coresentiment
USEnhancedDataSource -> usenhanced
CNEnhancedDataSource -> cnenhanced
HKEnhancedDataSource -> hkenhanced
```

### 缓存键格式

缓存管理器会自动生成标准格式的缓存键：

```
sentiment:ticker:data_type:date:hash
```

例如：
```
sentiment:688256:coresentiment:2025-10-28:a1b2c3d4
sentiment:AAPL:usenhanced:2025-10-28:e5f6g7h8
```

### 缓存TTL

不同数据类型使用不同的TTL：

| data_type | TTL | 说明 |
|-----------|-----|------|
| vix | 5分钟 | VIX指数 |
| news | 30分钟 | 新闻情绪 |
| price | 5分钟 | 价格动量 |
| volume | 5分钟 | 成交量 |
| northbound | 1小时 | 北向资金 |
| margin | 1小时 | 融资融券 |
| southbound | 1小时 | 南向资金 |
| reddit | 1小时 | Reddit情绪 |
| volatility | 1小时 | 波动率 |
| composite | 5分钟 | 综合评分 |
| 其他 | 1小时 | 默认值 |

## 影响范围

### 修改的文件

- `tradingagents/dataflows/sentiment_data_sources.py`

### 影响的类

- `SentimentDataSource` (基类)
- `CoreSentimentDataSource`
- `USEnhancedDataSource`
- `CNEnhancedDataSource`
- `HKEnhancedDataSource`

所有继承自 `SentimentDataSource` 的类都会受益于这个修复。

## 预期效果

### 修复前

```
ERROR | [情绪工具] 获取市场情绪数据失败: SentimentCacheManager.get() missing 1 required positional argument: 'data_type'
```

### 修复后

```
DEBUG | 缓存未命中，获取新数据: 688256:coresentiment:2025-10-28
INFO  | [情绪工具] 获取核心情绪数据...
INFO  | [情绪工具] 核心组件评分: {...}
DEBUG | 数据已缓存: 688256:coresentiment:2025-10-28, TTL=1800s
```

## 测试验证

### 1. 重启服务

```bash
docker-compose restart backend
```

### 2. 提交测试分析

提交一个分析请求，观察日志。

### 3. 验证缓存

第一次请求：
```
DEBUG | 缓存未命中，获取新数据
INFO  | 数据已缓存
```

第二次请求（TTL内）：
```
DEBUG | 缓存命中: 688256:coresentiment:2025-10-28
```

### 4. 检查Redis（如果启用）

```bash
redis-cli
> KEYS sentiment:*
> TTL sentiment:688256:coresentiment:2025-10-28:*
```

## 兼容性

### 缓存后端

- ✅ Redis缓存
- ✅ 文件缓存
- ✅ 自动降级

### 数据源

- ✅ 核心情绪数据源
- ✅ 美股增强数据源
- ✅ A股增强数据源
- ✅ 港股增强数据源

## 性能优化

### 缓存命中率

正常情况下，缓存命中率应该在50%以上：

```python
from tradingagents.dataflows.sentiment_cache import get_sentiment_cache

cache = get_sentiment_cache()
stats = cache.get_stats()
print(f"命中率: {stats['hit_rate']:.2%}")
```

### 缓存大小

- Redis: 自动管理，使用LRU策略
- 文件: 定期清理过期文件

```python
# 清理过期缓存
cache.clear_expired()
```

## 总结

✅ **修复了缓存接口不匹配** - 使用正确的参数调用
✅ **统一了缓存键格式** - 由缓存管理器统一生成
✅ **保持了向后兼容** - 不影响现有功能
✅ **提高了可维护性** - 接口更清晰

现在缓存功能应该能够正常工作了！
